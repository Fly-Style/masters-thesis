\chapter{WebAssembly}

\section{Abstract}



\section{WebAssembly Overview}
\subsection{}
\subsection{}

\section{WebAssembly Specification}
\subsection{}
\subsection{}

\section{Overview of Rivals}
\subsection{Java Applets} \mbox{}\\
\indent A Java applet is a small application is written in the Java language, or another programming language that compiles to Java bytecode (JVM intermediate representation), and delivered to users in the form of Java bytecode. 
The browser user launched the Java applet from a web page, and the applet was then executed within JVM were launched in separate process from the web browser itself. 
Programmers could appear a Java applets in any frame of the web page, a new application window, Sun's AppletViewer, or an another stand-alone tool.

Java applets had access to hardware acceleration, making them well-suited for non-trivial, computation-intensive visualizations. When applets were popular, JavaScript engines didn't have GPU support.
As browsers have gained support for hardware-accelerated graphics thanks to the canvas technology (or specifically WebGL in the case of 3D graphics), 
as well as just-in-time compiled JavaScript became very efficient, the speed difference has become less noticeable.

The applet can be displayed on the web page by making use of the deprecated applet HTML element, or the recommended object element.
The embed element can be used with Mozilla family browsers (embed was deprecated in HTML 4 but is included in HTML 5). 
This specifies the applet's source and location. 
Both object and embed tags can also download and install Java virtual machine (if required) or at least lead to the plugin page. 
\texttt{applet} and \texttt{{object}} tags also support loading of the serialized applets that start in some particular (rather than initial) state. 
Tags also specify the message that shows up in place of the applet if the browser cannot run it due to any reason \cite{Wiki_Applet}.

Java applets were deprecated since JDK 9 in 2017 and removed from JDK 11, released in September 2018.

\textit{\textbf{By definition, Java bytecode is platform independent intermediate representation, Java applets can be executed by browsers (or other clients) for many platforms, including Microsoft Windows, FreeBSD, Unix, macOS and Linux.}}
\textit{\textbf{They cannot be run on modern mobile devices, which do not support Java.}}

\subsection{Microsoft Silverlight} \cite{Wiki_Silver}

Microsoft Silverlight (or simply Silverlight) was an application framework for writing and running rich Internet applications, similar to Adobe Flash. 
A plugin for Silverlight is still available for some browsers. 
While early versions of Silverlight focused on streaming media, later versions supported multimedia, graphics, and animation and gave developers support for CLI languages and development tools.

Silverlight provides a retained mode graphics system similar to Windows Presentation Foundation (WPF), and integrates multimedia, graphics, animations, and interactivity into a single run-time environment. 
In Silverlight applications, user interfaces are declared in Extensible Application Markup Language (XAML) and programmed using a subset of the .NET Framework. 
XAML can be used for marking up the vector graphics and animations.

Silverlight supports H.264 video, Advanced Audio Coding, Windows Media Video (WMV), Windows Media Audio (WMA), and MPEG Layer III (MP3) 
media content across all supported browsers without requiring Windows Media Player, the Windows Media Player ActiveX control, or Windows Media browser plug-ins. 
Silverlight exposes a Downloader object which can be used to download content, like scripts, media assets, or other data, as may be required by the application.
With version II, the programming logic can be written in any .NET language, including some derivatives of common dynamic programming languages like \textbf{IronRuby} and \textbf{IronPython}.

Cross platform Mozilla Firefox support for Silverlight was removed in Firefox 52 released in March 2017 when Mozilla removed support for NPAPI plugins,[40] bringing it in-line with the removal of NPAPI plugin support in Google Chrome.

\subsection{Adobe Flash} \cite{Wiki_Flash}

Adobe Flash Player is computer software for using content created on the Adobe Flash platform, including viewing multimedia contents, executing rich Internet applications, and streaming audio and video. 
Flash Player can run from a web browser as a browser plug-in or on supported mobile devices. 
Flash Player was created by Macromedia and has been developed and distributed by Adobe Systems since Adobe acquired Macromedia in 2005. 

Flash Player runs \textbf{SWF} files that can be created by Adobe Flash Professional, Adobe Flash Builder or by third party tools such as FlashDevelop. 
Flash Player supports vector graphics, 3D graphics, embedded audio, video and raster graphics, and a scripting language called \textbf{ActionScript}. 
ActionScript is based on ECMAScript (similar to JavaScript) and supports object-oriented code. 
Flash Player is distributed free of charge and its plug-in versions are available for every major web browser and operating system. 
Google Chrome, Internet Explorer 11 in Windows 8 and later, and Microsoft Edge come bundled with a sandboxed Adobe Flash plug-in.

Flash Player once had a large user base, and was a common format for web games, animations, and graphical user interface (GUI) elements embedded in web pages. 
Adobe stated in 2013 that more than 400 million out of over 1 billion connected desktops update to the new version of Flash Player within six weeks of release. 

Flash Player has become increasingly criticized for its performance, consumption of battery on mobile devices, the number of security vulnerabilities that had been discovered in the software, and its closed platform nature.

In July 2017, Adobe announced that it would end support for Flash Player in 2020, and continued to encourage the use of open HTML5 standards in place of Flash. 
The announcement was coordinated with all tech giantes.
Its usage has also waned because of modern web standards that allow some of Flash's use cases to be fulfilled without third-party plugins.

\subsection{asm.js} \cite{asm17}

asm.js a very small, strict subset of JavaScript that only allows things like \texttt{while}, \texttt{if}, numbers, top-level named functions, and other simple constructs. 
It does not allow objects, strings, closures, and basically anything that requires heap allocation. 
Asm.js code resembles C in many ways, but it's still completely valid JavaScript that will run in all current engines. 
It pushes JS engines to optimize this kind of code, and gives compilers like Emscripten a clear definition of what kind of code to generate. 
We will show what asm.js code looks like and explain how it helps and how you can use it.

This subset of JavaScript is already highly optimized in many JavaScript engines using fancy Just-In-Time (JIT) compiling techniques. 
However, by defining an explicit standard we can work on optimizing this kind of code even more and getting as much performance as we can out of it. 
It makes it easier to collaborate across multiple JS engines because it's easy to talk about and benchmark. 
The idea is that this kind of code should run very fast in each engine, and if it doesn't, it's a bug and there's a clear spec that engines should optimize for.

It also makes it easy for people writing compilers that want to generate high-performant code on the web. 
They can consult the asm.js spec and know that it will run fast if they adhere to asm.js patterns. 
Emscripten, a C/C++ to JavaScript compiler, emits asm.js code to make it run with near native performance on several browsers.

Additionally, if an engine chooses to specially recognize asm.js code, there even more optimizations that can be made. 
Firefox is the only browser to do this right now.

\subsection{Comparison WebAssembly with Rivals}
\subsubsection{WebAssembly vs rich applications}\mbox{}\\
So-called 'rich' application is an application that is executing on browser plugin which supports programming language, unlike WebAssembly.
WebAssembly application user doesn't require any additional plugins, this is native browser technology.

We can summarize all advantages in list of WebAssembly's major features which don't available in 'rich' applications :
\begin{itemize}  
  \item \textbf{Performance}. Designed as low-level binary instruction set, it provides high speed of parsing and execution which is higher than execution of 'rich' application. 
                Also, it uses SIMD instructions, atomic operations. Threads and GC are intended to implement in WASM engines. 
  \item \textbf{Security}. WebAssemblyâ€™s applications and JS in browsers use same API for communication with hardware and OS.
  \item \textbf{JS compatibility with WebAssembly}.
  \item \textbf{Language-independent}. It does not privilege any particular language, programming model, or object model, unlike in 'rich' applications, 
                which depend from concrete target virtual machine or programming language.
  \item \textbf{Compact}. WebAssembly has a binary format which is smaller than typical text or native code formats.
  \item \textbf{Open}. WebAssembly is open format with community-driven specification, unlike 'rich' applications which have vendor-locked specification.

\end{itemize}

\subsubsection{WebAssembly vs asm.js}\mbox{}\\
\indent As it was defined higher, asm.js is just a subset of JavaScript language, which gives a possibility to write more performant code using types and low-level data manipulations.
I assume that asm.js's has that biggest problems: highly increased code complexity (complex developer experience) and small browser support (Firefox).

We can summarize all advantages of WebAssembly over \texttt{asm.js} :
\begin{itemize}  
  \item \textbf{Fast application startup}. WebAssembly is designed to have small size. That fact means that web-application have a possibility to download it faster and have faster application start up.
               WebAssembly improves on parsing in a much bigger way: It can be parsed an order of magnitude faster than JavaScript (and asm.js as well). 
               This mostly comes down to binary formats being faster to parse, especially ones designed for that. 
               WebAssembly also makes it easy to parse (and optimize) functions in parallel, which helps a lot on multicore machines.
  \item \textbf{Optimized execution}. WebAssembly also makes it easy to parse (and optimize) functions in parallel, which helps a lot on multicore machines.
\end{itemize}